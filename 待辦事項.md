1) CSS：面板隱藏時的「無縫嵌入」樣式

把這段加到你現有 <style>（第二個 style 區塊）最後面即可：

/* 面板隱藏 → 與 Notion 無縫融合（透明、零邊距、無陰影） */
.ui-hidden .panel{ display:none !important; }
.ui-hidden #content{ background:transparent !important; padding:0 !important; }
.ui-hidden .wrap{ background:transparent !important; border:none !important; box-shadow:none !important; }

/* 有助 Notion 正確抓到內嵌高度 */
html, body { height:auto; }


用一個 body 等級的 class（.ui-hidden）來驅動透明化，比只加 #content.transparent-bg 更保險，能把任何背景/陰影/邊框完全拔乾淨。

2) JS：加一個可重用的 togglePanel()，並在隱藏時套用 .ui-hidden

在你的 <script> 裡，找「隱藏面板」的按鈕監聽器，改成這樣：

function togglePanel(){
  const controls = $('#controls');
  const hidden = controls.classList.toggle('hidden');
  // 面板隱藏時，body 套用 ui-hidden；顯示時移除
  document.body.classList.toggle('ui-hidden', hidden);

  // 若仍想保留你原本的 transparent-bg 樣式，也可以同步處理
  $('#content').classList.toggle('transparent-bg', hidden);

  syncUrl();
  tickResize();
}

$('#toggleUi').addEventListener('click', togglePanel);


同時，在 applyFromParams() 裡也要同步處理 ui 狀態（一開始就從網址帶 ui=0/1 時）——把你原本這段：

const ui = params.get('ui');
if(ui === '0') $('#controls').classList.add('hidden');


改成：

const ui = params.get('ui');
if (ui === '0') {
  $('#controls').classList.add('hidden');
  document.body.classList.add('ui-hidden');
  $('#content').classList.add('transparent-bg'); // 若要沿用你的 class
} else {
  $('#controls').classList.remove('hidden');
  document.body.classList.remove('ui-hidden');
  $('#content').classList.remove('transparent-bg');
}

3) JS：把快捷鍵改成「Shift + P」（不需要 Ctrl/⌘）

把你現在的這段快捷鍵（Ctrl+Shift+M）整段替換成下面的版本：

// Shift + P：切換面板顯示/隱藏（不需要 Ctrl/⌘）
// 小提醒：在 Notion 內嵌時，要先點一下 widget 讓 iframe 取得焦點，快捷鍵才會送進來。
document.addEventListener('keydown', (e)=>{
  const isShiftP = e.shiftKey && !e.ctrlKey && !e.metaKey && !e.altKey &&
                   (e.key === 'P' || e.key === 'p');
  if (isShiftP) {
    e.preventDefault();           // 避免 contenteditable 插入字元
    togglePanel();
  }
});


你之前用的是 Ctrl+Shift+M，而且當 #controls 隱藏後就沒有別的熱鍵能叫回來；這版會在 面板顯示/隱藏兩種狀態都有效。
也順手 preventDefault()，避免 contenteditable 在按鍵時插入「P」。

4) JS：修正高度計算，避免面板隱藏/切換時出現底部留白

把現有 tickResize()（你目前是用 document.documentElement.scrollHeight）替換為：

let resizeTimer;

function currentContainer(){
  // 有 Gate 就抓 Gate，否則抓編輯器容器
  const gateVisible = !$('#gate').classList.contains('hidden');
  return gateVisible ? $('#gate') : $('#editorContainer');
}

function tickResize(){
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(()=>{
    const target = currentContainer();
    const h = Math.max(1, target.scrollHeight);
    document.body.style.height = h + 'px';
    document.documentElement.style.height = h + 'px';
  }, 50);
}

// 觀察 editorContainer 底下的內容變化（切模式/打字/展開等）
const obs = new MutationObserver(tickResize);
obs.observe($('#editorContainer'), {childList:true, subtree:true, characterData:true});

window.addEventListener('resize', tickResize);


這樣高度是依「目前顯示的容器」來算（Gate 或編輯器），不會把隱藏的面板高度算進去，自然就沒有白底/留白問題。

5) （可選）讓網址也跟著紀錄 UI 狀態

若你希望 ?ui=0/1 跟著面板切換自動更新，把 syncUrl() 裡的這行：

q.set('ui', $('#controls').classList.contains('hidden') ? '0' : '1');


改為用 body 狀態判斷（與 CSS 一致）：

q.set('ui', document.body.classList.contains('ui-hidden') ? '0' : '1');
