超可以！先說重點：**因為你的 widget 是以 iframe 方式嵌入 Notion**，我們**無法在 Notion 頁面上真正建立原生的 Paragraph / Heading / List…區塊**；但我們可以在 widget 內\*\*視覺與互動上「模擬」\*\*這些區塊（含待辦勾選、摺疊、程式碼高亮、KaTeX 顯示等），而且保留你已做好的字體/配色/Icon Gate 功能。下面給你「最小變更」的增強方案，直接貼到你目前的 `index.html` 即可（我已閱讀你上傳的版本，內含 Icon Gate 與字體清單擴充）

---

# 要做什麼（概要）

1. **擴充模式選單**：加入 Paragraph/Headings/H1\~H3、To-Do、Bulleted、Numbered、Toggle、Quote、Code、Math。
2. **加一個 `renderBlock()`**：依模式輸出對應的 HTML 模板到 `#content`，並保留你的樣式變數（字體、大小、顏色、accent…）。
3. **少量 CSS**：補上 code/quote/list/toggle 的樣式。
4. **（選配）KaTeX**：讓 Math 模式渲染 `$...$` 或 `$$...$$`。

> 你的現有功能（Icon Gate、字體選單、URL 參數同步、控制面板）全部保留。

---

# 1) HTML：擴充「模式」選單

把你檔案中的「模式」下拉選單改為（或新增下列選項）：

```html
<label>模式
  <select id="mode">
    <option value="plain">Paragraph</option>
    <option value="h1">Heading 1</option>
    <option value="h2">Heading 2</option>
    <option value="h3">Heading 3</option>
    <option value="todo">To-Do List</option>
    <option value="bulleted">Bulleted List</option>
    <option value="numbered">Numbered List</option>
    <option value="toggle">Toggle List</option>
    <option value="quote">Quote</option>
    <option value="callout">Callout</option>
    <option value="strip">Left Strip</option>
    <option value="code">Code Block</option>
    <option value="math">Math (KaTeX)</option>
  </select>
</label>
```

---

# 2) CSS：補必要樣式

在你現有 `<style>` 裡追加（不會破壞原樣式）：

```css
/* Headings（沿用你的 --font/--size/--weight，可在 render 時調整 size/weight） */
.h1 { font-size: calc(var(--size) * 1.8); font-weight: 700; letter-spacing: -0.01em; }
.h2 { font-size: calc(var(--size) * 1.5); font-weight: 700; letter-spacing: -0.005em; }
.h3 { font-size: calc(var(--size) * 1.25); font-weight: 700; }

.quote { border-left: 4px solid var(--accent); padding-left: 12px; opacity: .9; }

.ul, .ol { padding-left: 1.25em; }
.ul li { list-style: disc; margin: 6px 0; }
.ol li { list-style: decimal; margin: 6px 0; }

.todo { display: grid; gap: 8px; }
.todo-item { display: grid; grid-template-columns: 20px 1fr; align-items: start; gap: 8px; }
.todo-item input[type="checkbox"] { margin-top: 4px; }
.todo-item.done .todo-text { text-decoration: line-through; opacity: .6; }

.toggle { border: 1px dashed color-mix(in oklab, var(--accent) 25%, #0000 75%); border-radius: 10px; }
.toggle summary { cursor: pointer; padding: 8px 10px; font-weight: 600; color: var(--text); }
.toggle .toggle-body { padding: 8px 12px 12px; opacity: .95; }

.codewrap { background: #0b1220; color: #eaeefb; border-radius: 10px; padding: 12px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; overflow:auto; }
.codewrap code { white-space: pre; display:block; line-height: 1.6; }

/* Math 置中顯示（可依需求微調） */
.math { display:grid; place-items:center; padding: 8px; }

/* 讓 contenteditable 內的 list/todo 好編輯 */
[contenteditable] li, [contenteditable] .todo-item, [contenteditable] summary { outline: none; }
```

---

# 3) JS：加入 renderBlock() 與事件串接

在你的 `<script>` 裡，於變數/工具函數之後、初始化之前，加上：

```js
function renderBlock(mode, initial=false){
  const c = $('#content');

  // 保留既有「純文字內容」以便切換模式不遺失（部分模式會包裝）
  const raw = c.innerText.trim() || (initial ? '' : '');

  // 預設：清掉舊的「callout/strip」類別，由各模式自行決定
  c.classList.remove('callout','strip','h1','h2','h3','quote','math');

  // 依模式產生模板
  switch(mode){
    case 'plain': {
      c.innerHTML = `<div class="p" contenteditable="true">${raw || '在這裡輸入段落文字…'}</div>`;
      break;
    }
    case 'h1': {
      c.classList.add('h1');
      c.innerHTML = `<div contenteditable="true">${raw || 'Heading 1'}</div>`;
      break;
    }
    case 'h2': {
      c.classList.add('h2');
      c.innerHTML = `<div contenteditable="true">${raw || 'Heading 2'}</div>`;
      break;
    }
    case 'h3': {
      c.classList.add('h3');
      c.innerHTML = `<div contenteditable="true">${raw || 'Heading 3'}</div>`;
      break;
    }
    case 'quote': {
      c.classList.add('quote');
      c.innerHTML = `<div contenteditable="true">${raw || '引言文字…'}</div>`;
      break;
    }
    case 'bulleted': {
      c.innerHTML = `<ul class="ul" contenteditable="true">
        <li>${raw || '項目一'}</li>
        <li>項目二</li>
        <li>項目三</li>
      </ul>`;
      break;
    }
    case 'numbered': {
      c.innerHTML = `<ol class="ol" contenteditable="true">
        <li>${raw || '步驟一'}</li>
        <li>步驟二</li>
        <li>步驟三</li>
      </ol>`;
      break;
    }
    case 'todo': {
      c.innerHTML = `<div class="todo" contenteditable="false">
        ${['待辦事項一','待辦事項二','待辦事項三'].map((t,i)=>`
          <div class="todo-item" data-i="${i}">
            <input type="checkbox"/>
            <div class="todo-text" contenteditable="true">${i===0 && raw ? raw : t}</div>
          </div>`).join('')}
      </div>`;
      // 點 checkbox 加上 done 樣式
      c.querySelectorAll('.todo-item input[type="checkbox"]').forEach(chk=>{
        chk.addEventListener('change', e=>{
          const item = e.target.closest('.todo-item');
          item.classList.toggle('done', e.target.checked);
          tickResize();
        });
      });
      break;
    }
    case 'toggle': {
      c.innerHTML = `<details class="toggle">
        <summary contenteditable="true">${raw || '點擊展開／收合標題'}</summary>
        <div class="toggle-body" contenteditable="true">在這裡輸入展開內容…</div>
      </details>`;
      break;
    }
    case 'code': {
      c.innerHTML = `<pre class="codewrap"><code contenteditable="true">${raw || 'console.log(\"Hello Notion Widget\");'}</code></pre>`;
      break;
    }
    case 'math': {
      c.classList.add('math');
      // 以 KaTeX 顯示；若沒載入 KaTeX 則退回純文字
      const expr = raw || String.raw`E = mc^2`;
      if (window.katex) {
        c.innerHTML = `<div id="mathbox"></div>`;
        katex.render(expr, $('#mathbox'), { throwOnError:false, displayMode:true });
      } else {
        c.innerHTML = `<div contenteditable="true">$$ ${expr} $$</div>`;
      }
      break;
    }
    case 'callout': {
      c.classList.add('callout');
      c.innerHTML = `<div contenteditable="true">${raw || '這是 Callout 內容…'}</div>`;
      break;
    }
    case 'strip': {
      c.classList.add('strip');
      c.innerHTML = `<div contenteditable="true">${raw || '這是左側重點條樣式…'}</div>`;
      break;
    }
    default: {
      // 回退 Paragraph
      c.innerHTML = `<div class="p" contenteditable="true">${raw || '在這裡輸入段落文字…'}</div>`;
    }
  }

  tickResize();
  syncUrl(); // 讓網址保持最新（仍沿用你原本的參數策略）
}
```

把原本你針對 `mode` 所做的 class 切換，改成在 `renderBlock()` 內處理（或保留原本也行，但要避免重複）。接著在你現有的 `map` 裡，把 `mode` 的行為換成呼叫 `renderBlock`：

```js
map.mode = v => renderBlock(v);
```

並在初始化流程（`applyFromParams()` 之後）加一行依參數渲染一次：

```js
const initialMode = params.get('mode') || 'plain';
renderBlock(initialMode, /*initial=*/true);
```

> 你的 `#content` 本來就 `contenteditable`，以上模板也都能直接編輯。To-Do 我讓 checkbox 有 strike-through 效果；Toggle 用 `<details><summary>`，原生可展開收合。

---

# 4)（可選）載入 KaTeX（Math 模式）

在 `<head>` 內追加（CDN 方案）：

```html
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
```

> 之後在 Math 模式下輸入 `$...$` 或 `$$...$$` 的內容，`renderBlock('math')` 會用 `katex.render()` 顯示；若離線或無法載入，會退回可編輯的純文字。

## UX 小建議

* 在控制面板 **mode** 旁邊加個「**插入範例**」按鈕，快速放入預設清單/待辦/程式碼模板（其實上面的 `renderBlock()` 已經幫你做了初始樣板）。
* 若要**多段不同字體/顏色**：可在工具列多加兩個下拉（字體/顏色）並使用 `document.execCommand`（雖然過時但仍可用）或 `Range` API 對選取文字加 `<span style="...">`。
* 列表內按 **Enter** 新增項目、**Shift+Tab/Tab** 改變縮排，可以做輕量鍵盤事件增強。

